# -*- coding: utf-8 -*-
"""CI hill climbing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L2t07LWsyA2-TyeqAH30jEb01xzjYlBA
"""

import random
def objective_function(x):
    return x**2 - 4*x + 4

def get_neighbor(x, step_size=0.1):
    return x + random.uniform(-step_size, step_size)

def simple_hill_climbing(initial_state, max_iterations=100, step_size=0.1):
    current_state = initial_state
    current_value = objective_function(current_state)

    for _ in range(max_iterations):

        neighbor = get_neighbor(current_state, step_size)
        neighbor_value = objective_function(neighbor)

        # If the neighbor is better, move to the neighbor
        if neighbor_value > current_value:
            current_state = neighbor
            current_value = neighbor_value

    return current_state, current_value


def steepest_ascent_hill_climbing(initial_state, max_iterations=100, step_size=0.1):
    current_state = initial_state
    current_value = objective_function(current_state)

    for _ in range(max_iterations):
        best_neighbor = None
        best_value = current_value

        # Explore all possible neighbors and choose the best one
        for i in range(-5, 6):  # Testing all neighbors in a range
            neighbor = current_state + i * step_size
            neighbor_value = objective_function(neighbor)

            if neighbor_value > best_value:
                best_value = neighbor_value
                best_neighbor = neighbor

        # If a better neighbor was found, move to it
        if best_neighbor is not None:
            current_state = best_neighbor
            current_value = best_value

    return current_state, current_value


def stochastic_hill_climbing(initial_state, max_iterations=100, step_size=0.1):
    current_state = initial_state
    current_value = objective_function(current_state)

    for _ in range(max_iterations):
        neighbor = get_neighbor(current_state, step_size)
        neighbor_value = objective_function(neighbor)


        if neighbor_value > current_value:
            current_state = neighbor
            current_value = neighbor_value

    return current_state, current_value

initial_state = random.uniform(-10, 10)

solution_simple, value_simple = simple_hill_climbing(initial_state)
print(f"Simple Hill Climbing: Solution = {solution_simple}, Value = {value_simple}")

solution_steepest, value_steepest = steepest_ascent_hill_climbing(initial_state)
print(f"Steepest-Ascent Hill Climbing: Solution = {solution_steepest}, Value = {value_steepest}")

solution_stochastic, value_stochastic = stochastic_hill_climbing(initial_state)
print(f"Stochastic Hill Climbing: Solution = {solution_stochastic}, Value = {value_stochastic}")



"""QUESTION2"""

import random

def calculate_conflicts(board):
    n = len(board)
    conflicts = 0

    for i in range(n):
        for j in range(i + 1, n):
            if board[i] == board[j]:
                conflicts += 1
            elif abs(board[i] - board[j]) == abs(i - j):
                conflicts += 1

    return conflicts

def get_neighbors(board):
    neighbors = []
    n = len(board)

    for row in range(n):
        for col in range(n):
            if col != board[row]:
                new_board = board[:]
                new_board[row] = col
                neighbors.append(new_board)

    return neighbors

def hill_climbing(n, max_restarts=100):
    for restart in range(max_restarts):
        board = [random.randint(0, n-1) for _ in range(n)]
        current_conflicts = calculate_conflicts(board)

        while current_conflicts > 0:
            neighbors = get_neighbors(board)
            best_neighbor = None
            best_conflicts = current_conflicts

            for neighbor in neighbors:
                neighbor_conflicts = calculate_conflicts(neighbor)
                if neighbor_conflicts < best_conflicts:
                    best_conflicts = neighbor_conflicts
                    best_neighbor = neighbor

            if best_conflicts >= current_conflicts:
                break

            board = best_neighbor
            current_conflicts = best_conflicts

            if current_conflicts == 0:
                return board

    return None

def print_board(board):
    n = len(board)
    for i in range(n):
        row = ['.' for _ in range(n)]
        row[board[i]] = 'Q'  # Place the queen
        print(' '.join(row))
    print()

n = 4
solution = hill_climbing(n)

if solution:
    print("Solution found!")
    print_board(solution)
else:
    print("No solution found.")



"""question 3"""

import random

# Function to represent the current configuration of blocks
def print_state(state):
    for i, stack in enumerate(state):
        print(f"Stack {i}: {stack}")

# Function to calculate the number of blocks that are in their correct position
def calculate_conflicts(state, goal_state):
    conflicts = 0
    for i in range(len(state)):
        for j in range(len(state[i])):
            # Count conflicts when a block is not in the correct position
            if j >= len(goal_state[i]) or state[i][j] != goal_state[i][j]:
                conflicts += 1
    return conflicts

# Function to generate neighbors by moving a block
def generate_neighbors(state):
    neighbors = []
    for i in range(len(state)):
        if len(state[i]) == 0:
            continue
        # Try to move the top block from stack i to other stacks or to the table
        for j in range(len(state)):
            if i != j:  # Don't move a block onto the same stack
                new_state = [list(stack) for stack in state]  # Make a copy of the state
                block = new_state[i].pop()  # Remove the top block from stack i
                new_state[j].append(block)  # Add it to stack j
                neighbors.append(new_state)
    return neighbors

# Hill climbing algorithm for the Block World problem
def hill_climbing(initial_state, goal_state):
    current_state = initial_state
    current_conflicts = calculate_conflicts(current_state, goal_state)

    # Repeat until no conflicts or we get stuck
    while current_conflicts > 0:
        neighbors = generate_neighbors(current_state)
        next_state = None
        next_conflicts = current_conflicts

        # Find the neighbor with the least number of conflicts
        for neighbor in neighbors:
            conflict_count = calculate_conflicts(neighbor, goal_state)
            if conflict_count < next_conflicts:
                next_state = neighbor
                next_conflicts = conflict_count

        # If no better state is found, exit (we are stuck)
        if next_state is None:
            return None

        # Move to the next state
        current_state = next_state
        current_conflicts = next_conflicts

    return current_state

# Example usage
if __name__ == "__main__":
    # Initial state (blocks are represented by integers for simplicity)
    initial_state = [
        [1, 2],  # Stack 0: Blocks 1 and 2
        [3],     # Stack 1: Block 3
        [4],     # Stack 2: Block 4
        []       # Stack 3: Empty
    ]

    # Goal state (the desired configuration)
    goal_state = [
        [1],     # Stack 0: Block 1
        [2],     # Stack 1: Block 2
        [3],     # Stack 2: Block 3
        [4]      # Stack 3: Block 4
    ]

    print("Initial State:")
    print_state(initial_state)

    print("\nGoal State:")
    print_state(goal_state)

    # Solve using hill climbing
    solution = hill_climbing(initial_state, goal_state)

    if solution:
        print("\nSolution found:")
        print_state(solution)
    else:
        print("\nNo solution found.")

